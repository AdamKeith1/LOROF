# CSR List
ISA: RV32IMAC_Zicsr_Zifencei Sv32

## General Rules
- csr[11:0]
    - csr[11:10]
        - 00, 01, 10:
            - read/write
        - 11:
            - read-only
    - csr[9:8]
        - lowest executing privilege level that can access
        - 00:
            - User/Application
            - U-mode
        - 01:
            - Supervisor
            - S-mode
        - 10:
            - reserved
        - 11:
            - Machine
            - M-mode
- CSR's have associated privilege level where this privilege level and higher privilege levels can access it
    - raise illegal instruction exception if current privilege level not allowed to access CSR
- raise illegal instruciton exception if try to write to read-only register
    - writes to read-only fields of read/write registers are simply ignored
- dependent CSR's can affect the value of fields of other CSR's if a write to the CSR affects a dependent CSR's field
    - these value modifications do not cause CSR write side affects for the dependent CSR
- implicit CSR reads are equivalent in affect of explicit CSR reads
    - i.e. satp CSR modifications must propagate immediately

### CSR Fields
- WPRI
    - Reserved Writes Preserve Values, Reads Ignore Values
    - SW's job to maintain value if not writing to field
    - if unused: read-only zero
- WLRL
    - Write/Read Only Legal Values
    - only have to support legal values
    - OPTIONAL: raise illegal-instruction exception if SW writes illegal value
    - always read legal values unless wrote illegal value previously
- WARL
    - Write Any Values, Read Legal Values
    - SW can test field to see legal values by trying to write value and see what gets read
    - no exceptions if illegal value
    - always read legal values unless wrote illegal value previously

## Supported CSR's

### Unprivileged CSR's

#### FPU
- 0x001: fflags
    - FPU accrued exceptions
    - URW
    - F extension unsupported, illegal instr
- 0x002: frm
    - FPU dynamic rounding mode
    - URW
    - F extension unsupported, illegal instr
- 0x003: fcsr
    - FPU control and status register
        - superset of equivalent bits when read fflags, frm individually
    - URW
    - F extension unsupported, illegal instr

#### Counters, Timers
- 0xC00: cycle
    - user cycle counter
    - cycles since arbitrary time in past
    - URO
    - alias to mcycle
- 0xC01: time
    - user time
    - real time since arbitrary time in past
    - tick at reasonable rate
        - when implement real time clock, probably some multiple of seconds or milliseconds or microseconds
    - URO
    - alias to read of mtime MMCSR
- 0xC02: instret
    - user instructions retired
    - instructions retired since arbitrary time in past
    - URO
    - don't increment for instructions causing synchronous exceptions
        - ECALL, EBREAK, illegal instr, etc.
    - alias to minstret
- 0xC03:0xC1F: hpmcounter3:31
    - perf monitoring counters
    - URO
    - alias to mhpmcounter3:31
- 0xC80: cycleh
    - upper 32 bits of cycle
    - URO
    - alias to mcycleh
- 0xC81: timeh
    - upper 32 bits of time
    - URO
    - alias to read of upper 32 bits of mtime MMCSR
- 0xC82: instreth
    - upper 32 bits of instret
    - URO
    - alias to minstreth
- 0xC83:0xC9F: hpmcounter3h:31h
    - upper 32 bits of hpmcounter[i]
    - URO
    - alias to mhpmcounter3h:31h

### Supervisor CSR's

#### Trap Setup
- 0x100: sstatus
    - supervisor status
    - SRW
- 0x104: sie
    - supervisor interrupt-enable
    - SRW
- 0x105: stvec
    - supervisor trap handler base address
    - SRW
- 0x106: scounteren
    - supervisor counter enable
    - SRW

#### Config
- 0x10A: senvcfg
    - supervisor environment config

#### Counter Setup
- 0x120: scountinhibit
    - supervisor sounter-inhibit
    - SRW

#### Trap Handling
- 0x140: sscratch
    - scratch register for supervisor trap handlers
    - SRW
- 0x141: sepc
    - supervisor exception PC
    - SRW
- 0x142: scause
    - supervisor trap cause
    - SRW
- 0x143: stval
    - supervisor bad address or instruction
    - SRW
- 0x144: sip
    - supervisor interrupt pending
    - SRW
- 0xDA0: scountovf
    - supervisor count overflow
    - unsupported
    -   would be used for Sscofpmf extension for counter overflow diagnostics

#### VM
- 0x180: satp
    - supervisor address translation and protection
    - SRW

#### Debug/Trace
- 0x5A8: scontext
    - supervisor context
    - SRW
    - unratified, illegal instr

#### State Enable
- 0x10C:0x10F: sstateen0:3
    - supervisor state enables
    - SRW
    - for Smstateen extension
    - unsupported, illegal instr

### Machine CSR's
- M-mode-only accessible CSR's

#### Machine Info
- 0xF11: mvendorid
    - vendor ID
    - MRO
    - {32'h0}
        - non-commercial implementation
- 0xF12: marchid
    - architecture ID
    - MRO
    - {32'h0}
        - need to ask RISC-V International if want ID
- 0xF13: mimpid
    - implementation ID
    - MRO
    - {32'h0}
        - don't care for me
- 0xF14: mhartid
    - hardware thread ID
    - MRO
    - assign by core:
        - core0: 32'h0
            - reset core must be 32'h0
        - core1: 32'h1
        - core2: 32'h2
        - core3: 32'h3
- 0xF15: mconfigptr
    - pointer to configuration data structure
    - MRO
    - used by OpenSBI
        - figure out what should be for this platform
    - can be MMCSR read
    - can be hardwired addr
    - can be read-only zero

#### Trap Setup
- 0x300: mstatus
    - machine status
    - MRW
    - {SD, WPRI[7:0], TSR, TW, TVM, MXR, SM, MPRV, XS[1:0], FS[1:0], MPP[1:0], VS[1:0], SPP, MPIE, UBE, SPIE, WPRI, MIE, WPRI, SIE, WPRI}
        - MIE, SIE: 
            - interrupt enables
            - MIE:
                - M-mode interrupt enable
                - enable interrupts when executing in M-mode
                - WARL
            - SIE:
                - S-mode interrupt enable
                - enable interrupts when executing in S-mode
                - WARL
            - regardless of these values, still never get interrupted by interrupts for lower privilege modes
                - M-mode execution cannot be interrupted by S-mode level interrupt
            - regardless of these value, can still get interrupted by interrupts for higher privilege modes
                - S-mode execution can always be interrupted by M-mode level interrupt
                - U-mode execution can always be interrupted by M-mode or S-mode level interrupts
        - MPIE, SPIE, MPP, SPP: 
            - previous enables and privilege modes
            - make up two-level privilege mode stack
                - two-level in that save current and previous mode info
                - SW must be careful to maintain this stack e.g. guarantee no exceptions while saving privilege mode stack
            - MPIE:
                - M-mode previous interrupt enable
                - MIE value before this trap
                    - SW can restore MIE to this MPIE value if wants to disable interrupts to take care of this trap
                - WARL
            - SPIE:
                - S-mode previous interrupt enable
                - SIE value before this trap
                    - SW can restore SIE to this SPIE value if wants to disable interrupts to take care of this trap
                - WARL
            - MPP[1:0]:
                - M-mode previous privilege mode
                - 00: previously U-mode
                - 01: previously S-mode
                - 10: reserved
                - 11: previously M-mode
                - WARL
            - SPP:
                - S-mode previous privilege mode
                - 0: previously U-mode
                - 1: previously S-mode
                - WARL
            - HW support:
                - trap to M-mode
                    - set MPIE with MIE value
                    - set MPP with mode trapped from
                - trap to S-mode
                    - set SPIE with SIE value
                    - set SPP with mode trapped from
                - MRET
                    - see [Trap Return](#trap-return)
                - SRET
                    - see [Trap Return](#trap-return)
        - MPRV:
            - Modify Privilege
            - MPRV = 0:
                - use executing privilege mode's DATA (load/store/amo) memory translation and protection rules
            - MPRV = 1:
                - use DATA (load/store/amo) memory translation and protection rules designated by the MPP privilege mode
            - WARL
            - essentially, SW can enable translation and protection for M-mode loads and stores
                - e.g. misaligned load, can directly use virtual address that S-mode or U-mode tried to access
            - MPRV = 0 guaranteed for U-mode and S-mode
            - MPRV = 0 OR MPRV = 1 for M-mode
        - MXR: 
            - Make Executable Readable
            - MXR = 0:
                - normal translation and protection rules where can only load from page with R=1
            - MXR = 1:
                - allow loads from pages with X=1 or R=1
            - WARL
            - implies MPRV = 1 for this field to be relevant, when trying to do a translated and protected load in M-mode
        - SUM:
            - Permit Supervisor User Memory Access
            - SUM = 0:
                - S-mode accesses to U=1 pages will fault
            - SUM = 1:
                - S-mode accesses to U=1 pages are permitted
            - WARL
            - implies translation and protection in effect for this field to have an effect
            - relevant to M-mode when MPRV=1 & MPP=S-mode
                - this is when DATA memory accesses are effectively S-mode accesses
        - MBE, SBE, UBE:
            - byte endianness for DATA memory accesses
                - instruction accesses always little-endian
            - 0 for little endian, 1 for big endian
            - UBE = 1'b0:
                - U-mode Byte Endianness
                - WARL
                    - will ignore writes
            - SBE and MBE in mstatush
        - TVM:
            - Trap Virtual Memory
            - TVM = 0:
                - satp CSR reads/writes and SFENCE.VMA allowed in S-mode
            - TVM = 1:
                - satp CSR reads/writes and SFENCE.VMA raise an illegal-instruction exception in S-mode 
            - WARL
        - TW:
            - Timeout Wait
            - TW = 0:
                - S-mode can freely execute WFI
            - TW = 1:
                - S-mode use of WFI either:
                    - waits for bounded time before completing
                    - gives illegal instruction
            - WARL
            - U-mode use of WFI always either:
                - waits for bounded time before completing
                - gives illegal instruction
            - simple: 
                - TW = 1 & S-mode immediately gives illegal instruction
                - U-mode WFI always immediately gives illegal instruction
        - TSR:
            - Trap SRET
            - TSR = 0:
                - SRET is permitted in S-mode
            - TSR = 1:
                - SRET in S-mode raises illegal-instruction exception
            - WARL
        - FS, VS, XS, SD:
            - extension context status
                - 2 bits each for {Off, Initial, Clean, Dirty} states
            - FS[1:0]:
                - FPU state encoding
                - WARL
                    - allow writes and reads for FPU emulation in SW
            - VS[1:0] = 2'b00:
                - Vector state encoding
                - WARL
                    - allow writes and reads for FPU emulation in SW
            - XS[1:0] = 2'b00:
                - additional U-mode extension state encoding
                - WARL
                    - will ignore writes
            - SD:
                - SD = 0:
                    - none of FS, VS, XS dirty
                - SD = 1: 
                    - any of FS, VS, XS dirty
                - read-only
- 0x301: misa
    - ISA and extensions
    - MRW
    - {MXL[1:0], 4'b0000, Extensions[25:0]}
        - MXL[1:0] = 2'b01
            - Machine XLEN
            - WARL
                - will ignore writes
                    - else would need to be able to dynamically change XLEN
            - 2'b01 to denote XLEN = 32
        - Extensions[25:0] = 26'b00000101000001000100000101
            - Extensions A:Z
                - 0: A for Atomic
                - 2: C for Compressed
                - 8: I for RV32I
                - 12: M for Mul/Div
                - 18: S for Supervisor Mode
                - 20: U for User Mode
            - WARL
                - will ignore writes
                    - else would need to be able to dynamically change Extensions
- 0x302: medeleg
    - machine exception delegation
    - MRW
    - all exceptions trap to M-mode by default
    - set bits in medeleg, medelegh for corresponding exceptions to trap to S-mode when executing in S-mode or U-mode
        - corresponding exceptions executing in M-mode still trap to M-mode
    - bit indexes correspond to mcause bit indexes
        - following Interrupt = 1'b0
    - HW support for delegated exception:
        - set scause
        - set sepc
        - set stval
        - set mstatus.SPP following execution mode when trapped
        - set mstatus.SIE = 0
    - HW support for all bits as writeable 0 or 1:
        - means HW support for any exception delegatable 
        - exceptions that aren't possible in lower privileged modes are read-only zero
            - medeleg[11] = 1'b0
- 0x303: mideleg
    - machine interrupt delegation
    - MRW
    - mostly same semantics as medeleg but for interrupts
    - delegated interrupts are ignored in M-mode
        - instead of interrupting to M-mode if executing in M-mode, these are now ignored
    - bit indexes correspond to mcause bit indexes
        - following Interrupt = 1'b1
    - no midelegh
- 0x304: mie
    - machine interrupt enable
    - MRW
    - bit indexes correspond to mcause bit indexes
        - following Interrupt = 1'b1
    - when interrupt into M-mode for interrupt i:
        - either:
            - executing in M-mode and mstatus.MIE = 1'b1
            - executing in S-mode OR U-mode
        - mip[i] = 1'b1 & mie[i] = 1'b1
        - mideleg[i] = 1'b0
    - propagate changes to mip, mie, mstatus, mideleg immediately on MRET, SRET
    - propagate changes to mip, mie, mstatus, mideleg immediately on dependent CSR writes
    - M-mode interrupts take priority over S-mode delegated interrupts
    - bits of supported interrupts can be written by CSR writes
    - bits of unsupported interrupts are read-only zero
    - {upper16[15:0], 2'b00, LCOFIE, 1'b0, MEIE, 1'b0, SEIE, 1'b0, MTIE, 1'b0, STIE, 1'b0, MSIE, 1'b0, SSIE, 1'b0}
        - upper16[15:0] = 16'h0:
            - upper 16 bits are platform defined
            - HW custom interrupts here
                - none planned right now
        - LCOFIE = 1'b0:
            - unsupported
            - would be used for Sscofpmf extension for counter overflow interrupts
        - MEIE:
            - M External Interrupt Enable
        - MTIE:
            - M Timer Interrupt Enable
        - MSIE:
            - M Software Interrupt Enable
        - SEIE:
            - S External Interrupt Enable
        - STIE:
            - S Timer Interrupt Enable
        - SSIE:
            - S Software Interrupt Enable
- 0x305: mtvec
    - machine trap-vector base-address
    - MRW
    - {BASE[31:2], MODE[1:0]}
        - BASE:
            - base address of trap PC
            - give 4-byte aligned upper 30 PC bits
            - WARL
        - MODE:
            - trap vectorization enable
            - WARL
            - MODE = 2'b00: Direct
                - all exceptions and interrupts:
                    - PC <= BASE
            - MODE = 2'b01: Vectored
                - exceptions:
                    - PC <= BASE
                - interrupts:
                    - PC <= BASE + 4 * (interrupt cause)
            - MODE = 2'b10, 2'b11:
                - reserved
                - WARL so force to 2'b00 or 2'b01 if try to write these
- 0x306: mcounteren
    - machine counter enable
    - MRW
    - give access to shadow CSR reads for S-mode and U-mode using time, instret, and hpmcounter[i] U reg's
    - {HPM[31:3], IR, TM, CY}
        - CY:
            - CY = 0:
                - reads to cycle, cycleh by S-mode or U-mode CSR instr gives illegal instr
            - CY = 1:
                - reads to cycle, cycleh by S-mode or U-mode CSR instr permitted
        - TM:
            - TM = 0:
                - reads to time, timeh by S-mode or U-mode CSR instr gives illegal instr
            - TM = 1:
                - reads to time, timeh by S-mode or U-mode CSR instr permitted
        - IR:
            - IR = 0:
                - reads to instret, instreth by S-mode or U-mode CSR instr gives illegal instr
            - IR = 1:
                - reads to instret, instreth by S-mode or U-mode CSR instr permitted
        - HPM[31:3]:
            - HPM[i] = 0:
                - reads to hpmcounter[i], hpmcounter[i]h by S-mode or U-mode CSR instr gives illegal instr
            - HPM[i] = 1:
                - reads to hpmcounter[i], hpmcounter[i]h by S-mode or U-mode CSR isntr permitted
- 0x310: mstatush
    - upper 32 bits of mstatus
    - MRW
    - {WPRI[25:0], MBE, SBE, WPRI[3:0]}
        - MBE, SBE:
            - byte endianness for DATA memory accesses
                - instruction accesses always little-endian
            - 0 for little endian, 1 for big endian
            - MBE = 1'b0:
                - M-mode Byte Endianness
                - WARL
                    - will ignore writes
            - SBE = 1'b0:
                - S-mode Byte Endianness
                - WARL
                    - will ignore writes
- 0x312: medelegh
    - upper 32 bits of medeleg
    - MRW

#### Trap Handling
- 0x340: mscratch
    - scrath register for machine trap handlers
    - MRW
        - just read/write reg
- 0x341: mepc
    - machine exception PC
    - MRW
    - {mepc[31:1], 1'b0}
        - HW sets mepc[31:1] with the PC of the instruction interrupted or the instruction that raised the exception on a trap to M-mode
        - SW can freely write mepc[31:1]
- 0x342: mcause
    - machine trap cause
    - MRW
    - {Interrupt, Exception Code[30:0]}
        - Interrupt:
            - if interrupt, HW sets Interrupt = 1'b1
            - if exception, HW sets Interrupt = 1'b0
        - Exception Code[30:0]:
            - HW sets corresponding Exception Code bit
                - seems like only set highest exception: i.e. one hot
                - also seems like must cleanly order an interrupt vs. an exception since can't report both same cycle
            - Interrupt = 1:
                - [0]: Reserved = 1'b0
                - [1]: S software interrupt
                - [2]: Reserved = 1'b0
                - [3]: M software interrupt
                - [4]: Reserved = 1'b0
                - [5]: S timer interrupt
                - [6]: Reserved = 1'b0
                - [7]: M timer interrupt
                - [8]: Reserved = 1'b0
                - [9]: S external interrupt
                - [10]: Reserved = 1'b0
                - [11]: M external interrupt
                - [12]: Reserved = 1'b0
                - [13]: Counter-overflow interrupt = 1'b0
                    - unsupported
                - [14:15]: Reserved = 2'b00
                - [16:31]: platform's choice = 16'h0
                    - none planned
                    - maybe [16] for power-on reset
            - Interrupt = 0:
                - [0]: instr addr misaligned = 1'b0
                    - IALIGN=16, so won't happen
                - [1]: instr access fault
                    - PMA (supported) or PMP (unsupported)
                - [2]: illegal instr
                - [3]: breakpoint
                    - EBREAK
                - [4]: load addr misaligned
                    - TBD if will support
                - [5]: load access fault = 1'b0
                    - PMA (supported) or PMP (unsupported)
                - [6]: store/amo addr misaligned
                - [7]: store/amo access fault = 1'b0
                    - PMA (supported) or PMP (unsupported)
                - [8]: ECALL from U-mode
                - [9]: ECALL from S-mode
                - [10]: Reserved = 1'b0
                - [11]: ECALL from M-mode
                - [12]: instr page fault
                - [13]: load page fault
                    - includes LR.W
                - [14]: Reserved = 1'b0
                - [15]: store/amo page fault
                - [16:17]: Reserved = 2'b00
                - [18]: software check = 1'b0
                    - no extension present which would raise this
                        - e.g. for Spectre/Meltdown check
                - [19]: hardware error
                    - can use for unrecoverable fetch fault or other hardware bug detections
                - [20:23]: Reserved = 4'b0000
                - [24:30]: custom extensions = 7'h0
                    - unsupported
        - exception priority
            - priority exists, see spec, not worth putting here
            - platform doesn't do fancy speculation that would ever raise exception in different priority order, so no need to enforce a specific priority 
- 0x343: mtval
    - machine bad address or instruction
    - MRW
    - HW sets on all traps to M-mode
        - bad address exceptions:
            - breakpoint, addr misaligned, PMA or PMP access fault, or page fault
            - set to virtual address
                - PC for bad fetch addr
                - load/store/amo address for bad dmem access 
                    - only have this after dtlb lookup and no later, wouldn't want to complete instr anyway, so give ldu/stamofu page fault immediately after dtlb lookup
        - illegal instr:
            - write zero-extended instruction
                - compressed should follow {16'h0, instr[15:0]}
        - else: 
            - write 32'h0
    - SW can freely write
- 0x344: mip
    - machine interrupt pending
    - use this reg to give indication of existent interrupt
        - i.e. use these actual reg bits to determine if interrupt core
    - MRW
    - bit indexes correspond to mcause bit indexes
    - bits of supported interrupts can be cleared to 0 by CSR writes
    - bits of unsupported interrupts are read-only zero
    - {upper16[15:0], 2'b00, LCOFIP, 1'b0, MEIP, 1'b0, SEIP, 1'b0, MTIP, 1'b0, STIP, 1'b0, MSIP, 1'b0, SSIP, 1'b0}
        - upper16[15:0] = 16'h0:
            - upper 16 bits are platform defined
            - HW custom interrupts here
                - none planned right now
        - LCOFIP = 1'b0:
            - unsupported
            - would be used for Sscofpmf extension for counter overflow interrupts for mhpmevent[i] counters
        - MEIP:
            - M External Interrupt Pending
            - read-only by CSR instr's
            - set and cleared by PLIC
        - MTIP:
            - M Timer Interrupt Pending
            - read-only by CSR instr's
            - set when (mtime > mtimecmp)
            - cleared by writing to mtimecmp such that (mtime < mtimecomp) 
            - see [Machine Timer Registers](#machine-timer-registers)
        - MSIP:
            - M Software Interrupt Pending
            - read-only by CSR instr's
            - set and cleared by IPI MMCSR's
        - SEIP:
            - S External Interrupt Pending
            - written by M-mode SW to explicitly signal external interrupt for S-mode
            - PLIC can also signal the existence of a pending S external interrupt
                - this doesn't write SEIP bit
                - exists independently but used for reads
            - CSR read's follow SEIP bit OR PLIC signal
                - this fancy behavior only for SEIP
                    - supposedly for mimicking external interrupts
        - STIP:
            - S Timer Interrupt Pending
            - writable by CSR instr's so M-mode can signal timer interrupt to S-mode
        - SSIP:
            - S Software Interrupt Pending
            - writable by CSR instr's so M-mode can signal 
            - also set and cleared by IPI MMCSR's
    - priority:
        - MEI > MSI > MTI > SEI > SSI > STI > LCOFI
    - see mie ^ for remaining semantics
- 0x34A: mtinst
    - machine trap instruction (transformed)
    - MRW
    - H extension unsupported, illegal instr
- 0x34B: mtval2
    - machine bad guest physical address
    - MRW
    - H extension unsupported, illegal instr
    
#### Config
- 0x30A: menvcfg
    - machine environment config
    - MRW
    - 64-bit with menvcfgh
    - {STCE, PBMTE, ADUE, CDE, WPRI[25:0], PMM[1:0], WPRI[23:0], CBZE, CBCFE, CBIE[1:0], WPRI[2:0], FIOM}
        - FIOM:
            - Fence of I/O implies Memory
            - relevant for S-mode and U-mode
            - keep WARL but has no effect since all fence's imply both I/O and memory fenced
                - fundamental reason did this is because can't figure out if address is to I/O vs. memory until after dtlb, which is too late to enact an acquire for this platform
                    - this platform uses stall_mem_read in dispatch
                - consider changing for this platform
        - PBMTE = 1'b0:
            - Svpbmt extension for RV64I page attributes unsupported
        - ADUE = 1'b0:
            - Svadu extension for SW PTE A/D bit updates unsupported
        - CDE = 1'b0:
            - Smcdeleg extension for counter delegation to S-mode unsupported
        - STCE = 1'b0:
            - unratified Sstc extension unsupported
        - CBZE = 1'b0:
            - unratified Zicboz extension unsupported
        - {CBCFE, CBIE[1:0]} = 3'b000:
            - unratified Zicbom extension unsupported
        - PMM = 1'b0:
            - unratified Smnpm extension unsupported
    - really just 1-bit FIOM, which is bit unused by HW that can be written by SW, rest read-only zero
- 0x31A: menvcfgh
    - upper 32 bits of menvcfg
    - MRW
    - upper 32 bits are read-only zero
- 0x747: mseccfg
    - machine security config
    - MRW
    - unsupported, illegal instr
- 0x757: mseccfgh
    - upper 32 bits of mseccfg
    - MRW
    - unsupported, illegal instr

#### Memory Protection
- 0x3A0:0x3AF: pmpcfg0:15
    - PMP config's
    - MRW
    - unsupported, illegal instr
- 0x3B0:0x3EF: pmpaddr0:63
    - PMP addr's
    - MRW
    - unsupported, illegal instr

#### State Enable
- 0x30C:0x30F: mstateen0:3
    - machine state enables
    - MRW
    - for Smstateen extension
    - unsupported, illegal instr
- 0x31C:0x31F: mstateen0h:3h
    - upper 32 bits of mstateen[i]
    - MRW
    - for Smstateen extension
    - unsupported, illegal instr

#### Non-Maskable Interrupt Handling
- 0x740: mnscratch
    - NMI scratch reg
    - MRW
    - NMI's unsupported, illegal instr
- 0x741: mnepc
    - NMI PC
    - MRW
    - NMI's unsupported, illegal instr
- 0x742: mncause
    - NMI cause
    - MRW
    - NMI's unsupported, illegal instr
- 0x744: mnstatus
    - NMI status
    - MRW
    - NMI's unsupported, illegal instr

#### Counters, Timers
- 0xB00: mcycle
    - machine cycle 64-bit counter with mcycleh
    - MRW
    - can write to give new value to continue counting from
- 0xB02: minstret
    - machine instructions retired 64-bit counter with minstreth
    - instructions retired since arbitrary time in past
    - MRW
    - can write to give new value to continue counting from
    - don't increment for instructions causing synchronous exceptions
        - ECALL, EBREAK, illegal instr, etc.
- 0xB03:0xB1F: mhpmcounter3:31
    - machine perf monitoring 64-bit counters with mhpmcounter3h:31h
    - MRW
    - can write to give new value to continue counting from
    - platform-specific and ideally local to core for routing concerns
        - instrs dispatched
        - alu reg retired
        - alu imm retired
        - bru retired
        - mdu retired
        - ldu retired
        - store retired
        - amo retired
        - fence retired
        - sys retired
        - icache accesses
        - icache misses
        - itlb accesses
        - itlb misses
        - dcache accesses
        - dcache misses
        - dtlb accesses
        - dtlb misses
        - L2 cache accesses
        - L2 cache misses
- 0xB80: mcycleh
    - upper 32 bits of mcycle
    - MRW
- 0xB82: minstreth
    - upper 32 bits of minstret
    - MRW
- 0xB83:0xB9F: mhpmcounter3h:31h
    - upper 32 bits of mhpmcounter[i]
    - MRW

#### Counter Setup
- 0x320: mcountinhibit
    - machine counter inhibit
    - MRW
    - prevent increment of associated counter
    - {HPM[31:3], IR, 1'b0, CY}
        - CY:
            - CY = 0:
                - prevent increment of cycle, cycleh
            - CY = 1:
                - cycle, cycleh increment normally
        - IR:
            - IR = 0:
                - prevent increment of minstret, minstreth
            - IR = 1:
                - minstret, minstreth increment normally
        - HPM[31:3]:
            - HPM[i] = 0:
                - prevent increment of mhpmcounter[i], mhpmcounter[i]h
            - HPM[i] = 1:
                - hpmcounter[i], hpmcounter[i]h increment normally
- 0x323:0x33F: mhpmevent3:31
    - machine perf monitoring event selector
    - MRW
    - platform-specific
        - likely not worth it to define more than 29 counters, so event selects wouldn't be used
            - especially since can use partial fields in the counters
        - if do select, CSR's essentially treated as indirect reg's
        - TBD, but likely make all read-only hardwired value
- 0x723:0x73F: mhpmevent3h:31h
    - upper 32 bits of mhpmevent[i]
    - MRW
    - unsupported since no Sscofpmf extension

#### Debug/Trace
- 0x7A0: tselect
    - debug/trace trigger select
    - MRW
    - unratified, illegal instr
- 0x7A1: tdata1
    - debug/trace trigger data 1
    - MRW
    - unratified, illegal instr
- 0x7A2: tdata2
    - debug/trace trigger data 2
    - MRW
    - unratified, illegal instr
- 0x7A3: tdata3
    - debug/trace trigger data 3
    - MRW
    - unratified, illegal instr
- 0x7A8: mcontext
    - machine context
    - MRW
    - unratified, illegal instr

#### Debug Mode
- 0x7B0: dcsr
    - debug control and status
    - DRW
    - unratified, illegal instr
- 0x7B1: dpc
    - debug PC
    - DRW
    - unratified, illegal instr
- 0x7B2: dscratch0
    - debug scratch reg 0
    - DRW
    - unratified, illegal instr
- 0x7B3: dscratch1
    - debug scratch reg 1
    - DRW
    - unratified, illegal instr

### Machine MMCSR's
- memory-mapped machine-level CSR's

#### Machine Timer Registers
- mtime
    - 64-bit timer
        - since RV32I, use 2x reads
    - RW
        - SW can reset value
        - HW, timer module only determines count-up
- mtimecmp
    - 64-bit timer compare
    - give Machine Timer Interrupt when (mtime > mtimecmp)
    - clear Machine Timer Interrupt when (mtime < mtimecomp) 
    - RW
        - SW can reset value
        - SW's job to set lower 32b and upper 32b such that don't get spurious interrupt while changing the value

## Privileged Instructions

### Environment Call and Breakpoint
- ECALL
    - in U-mode: raise environment-call-from-U-mode exception
    - in S-mode: raise environment-call-from-S-mode exception
    - in M-mode: raise environment-call-from-M-mode exception
    - if exception delegated to S-mode:
        - set sepc with address of ECALL
    - if exception to M-mode:
        - set mepc with address of ECALL
- EBREAK, C.EBREAK
    - raise breakpoint exception
    - if exception delegated to S-mode:
        - set sepc with address of ECALL
    - if exception to M-mode:
        - set mpec with address of ECALL

### Trap Return
- MRET
    - pop M-mode privilege stack
        - set execution mode <= MPP
        - set MIE <= MPIE
        - set MPIE <= 1'b1
        - set MPP <= 2'b00 (U-mode)
        - set MPRV <= 1'b0 if MPP != 2'b11 (M-mode)
    - set PC <= mepc
    - permitted in M-mode
- SRET
    - pop S-mode privilege stack
        - set execution mode <= SPP
        - set SIE <= SPIE
        - set SPIE <= 1'b1
        - set SPP <= 1'b0 (U-mode)
        - set MPRV <= 1'b0
    - set PC <= sepc
    - permitted in M-mode 
    - permitted in S-mode if mstatus.TSR = 0

### Wait for Interrupt
- WFI
    - permitted in M-mode
    - permitted in S-mode if mstatus.TW = 0
    - permitted in S-mode but with HW time limit if mstatus.TW = 1
    - permitted in U-mode but with HW time limit
    - can use to signal to PLIC that this hart prime for external interrupts
    - WFI wakeup ignores mstatus.MIE, mstatus.SIE, always resuming execution after the WFI even if an interrupt won't be taken due to enable's being off for this mode
        - allows spooky in-current-code interrupt handling as opposed to trap jump
    - WFI wakeup ignores mideleg settings, always resuming execution after the WFI even if the interrupt wouldn't be taken in M-mode
    - WFI wakeup doesn't occur if the individual interrupt is not enabled via mie
        - allows mie to be true mask over mip functionality
    - if take interrupt, set mpec <= pc + 4, instr after WFI

## Excepting Instructions
- what CSR's to set
- PC following mtvec

## Interrupts
- what CSR's to set
- PC following mtvec

## Reset Functionality
- start execution in M-mode
- mstatus
    - mstatus.MIE <= 0
    - mstatus.MPRV <= 0
    - hardwired vals good-to-go
- misa
    - hardwired vals good-to-go
- inv reservation set
- PC <= platform-defined reset
- mcause
    - give reset condition
    - can use platform-specific conditions (e.g. interrupt=1, [16:30] causes)
    - can be 32'h0 for no special interpretation of reset
- everything else undefined, seems like just choose logical reset val
    - WARL's must be legal value